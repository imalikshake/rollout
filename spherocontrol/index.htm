<html>

<head>
</head>

<body>
    <center>
        Sphero positions
        <br />
        <canvas id="absoluteCvs" width="800" height="600" style="border:1px solid #000000;">
        </canvas>
        <br /> Drift data
        <br />
        <canvas id="spheroAngleCvs" width="200" height="200" style="border:1px solid #000000;">
        </canvas>
        <br />
        <canvas id="spheroAngles" width="600" height="100"></canvas>
        <br /> Kalman filtered position
        <br />
        <canvas id="kalmanData" width="600" height="200"></canvas>
    </center>
    <script src="/socket.io/socket.io.js"></script>
    <script type="text/javascript" src="smoothie.js"></script>
    <script>
    var smoothie = new SmoothieChart();
    smoothie.streamTo(document.getElementById("spheroAngles"));

    var spheroIPAngle = new TimeSeries();
    var spheroDataAngle = new TimeSeries();
    var spheroDrift = new TimeSeries();

    smoothie.addTimeSeries(spheroIPAngle, {
        strokeStyle: 'rgb(0, 255, 0)',
        lineWidth: 1
    });
    smoothie.addTimeSeries(spheroDataAngle, {
        strokeStyle: 'rgb(255, 0, 0)',
        lineWidth: 1
    });
    smoothie.addTimeSeries(spheroDrift, {
        strokeStyle: 'rgb(0, 191, 255)',
        lineWidth: 1
    });

    var smoothieKalman = new SmoothieChart();
    smoothieKalman.streamTo(document.getElementById("kalmanData"));
    var kalmanXData = new TimeSeries();
    smoothieKalman.addTimeSeries(kalmanXData, {
        strokeStyle: 'rgb(255, 255, 255)',
    });
    var kalmanYData = new TimeSeries();
    smoothieKalman.addTimeSeries(kalmanYData, {
        strokeStyle: 'rgb(125, 0, 125)',
    });

    var socket = io();
    socket.on('data', function(msg) {
        for (var dtype in msg) {
            switch (dtype) {
                case 'spheroData':
                    updateSpheroData(msg[dtype]);
                    break;
                case 'ipData':
                    updateIpData(msg[dtype]);
                    break;
                case 'kalmanData':
                    updateKalmanData(msg[dtype]);
                    break;
                default:
                    console.log('rip');
            }
        }
    });
    var control = {
        force: 0,
        direction: 0
    };
    var pressedKeys = {
        w: false,
        a: false,
        s: false,
        d: false,
    }
    document.addEventListener('keydown', function(event) {
        if (event.keyCode === 87) {
            pressedKeys.w = true;
        }
        if (event.keyCode === 65) {
            pressedKeys.a = true;
        }
        if (event.keyCode === 83) {
            pressedKeys.s = true;
        }
        if (event.keyCode === 68) {
            pressedKeys.d = true;
        }
        calcNewForce();
    });
    document.addEventListener('keyup', function(event) {
        if (event.keyCode === 87) {
            pressedKeys.w = false;
        }
        if (event.keyCode === 65) {
            pressedKeys.a = false;
        }
        if (event.keyCode === 83) {
            pressedKeys.s = false;
        }
        if (event.keyCode === 68) {
            pressedKeys.d = false;
        }
        calcNewForce();
    });

    function calcNewForce() {
        force = (pressedKeys.w || pressedKeys.a || pressedKeys.s || pressedKeys.d) ? 0.3 : 0.0;
        var x = pressedKeys.w + -pressedKeys.s;
        var y = pressedKeys.d + -pressedKeys.a;
        var direction = Math.atan2(y, x);
        // console.log(direction);
        socket.emit('force', {
            force: force,
            direction: direction
        });
    }

    var canvas1 = document.getElementById('absoluteCvs');
    var ctx1 = canvas1.getContext('2d');
    var canvas2 = document.getElementById('spheroAngleCvs');
    var ctx2 = canvas2.getContext('2d');

    var corners = [{
        x: 0,
        y: 0
    }, {
        x: 1280,
        y: 0
    }, {
        x: 1280,
        y: 720
    }, {
        x: 0,
        y: 720
    }];

    var selected = -1;

    canvas1.addEventListener('mousedown', function(event) {
        var mousePos = getMousePos(canvas1, event);
        // console.log('mousedown', mousePos);
        for (var i in corners) {
            var corner = coordToIpPos(corners[i]);
            var xdiff = (mousePos.x - corner.x);
            var ydiff = (mousePos.y - corner.y);
            if (xdiff * xdiff + ydiff * ydiff < 100) {
                selected = i;
            }
        }
    });
    canvas1.addEventListener('mousemove', function(event) {
        var mousePos = getMousePos(canvas1, event);
        if (selected !== -1) {
            corners[selected] = IpPosToCoord(mousePos);
            socket.emit('transform', {
                corners: corners
            });
        }
    });
    canvas1.addEventListener('mouseup', function(event) {
        selected = -1;
    });

    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    var spheroState = {
        absIp: {},
        rel: {},
        drift: {},
        angle: {},
        abs: {}
    };

    var anglef = 0;

    function circles() {
        anglef += 2 / 20;
        socket.emit('force', {
            force: 0.4,
            direction: anglef
        });
    }
    // setInterval(circles, 1000 / 20);

    function updateIpData(data) {
        if (!spheroState.absIp[data.name])
            spheroState.absIp[data.name] = {};
        if (!spheroState.drift[data.name])
            spheroState.drift[data.name] = {};
        if (!spheroState.angle[data.name])
            spheroState.angle[data.name] = {};

        spheroState.absIp[data.name].x = data.pos.x;
        spheroState.absIp[data.name].y = data.pos.y;


        spheroState.drift[data.name] = data.drift;
        spheroState.angle[data.name] = data.angle;

        // var drift = spheroState.angle.boo + Math.atan2(spheroState.rel.boo.y, spheroState.rel.boo.x)

        spheroDrift.append(new Date().getTime(), data.drift);
        spheroIPAngle.append(new Date().getTime(), data.angle);

    }

    function updateSpheroData(data) {
        if (!spheroState.rel[data.name])
            spheroState.rel[data.name] = {};

        var dx = spheroState.rel[data.name].x = data.data.x;
        var dy = spheroState.rel[data.name].y = data.data.y;

        var spheroAngle = Math.atan2(dy, dx);

        spheroDataAngle.append(new Date().getTime(), spheroAngle);
    }

    function updateKalmanData(data) {
        if (!spheroState.abs[data.name])
            spheroState.abs[data.name] = {};
        var x = data.d[0];
        var y = data.d[1];
        kalmanXData.append(new Date().getTime(), x);
        kalmanYData.append(new Date().getTime(), y);

        spheroState.abs[data.name] = {
            x: x,
            y: y
        };
    }

    function drawCircle(pos, r, fill) {
        fill = fill || false;
        ctx1.beginPath();
        ctx1.arc(
            pos.x,
            pos.y,
            r,
            0, 2 * Math.PI
        );
        if (fill)
            ctx1.fill();
        else
            ctx1.stroke();
    }

    function orthoToIpPos(point) {
        return {
            x: (point.x + 1) / 2 * 300 + 250,
            y: (-point.y + 1) / 2 * 200 + 200
        }
    }

    function coordToIpPos(point) {
        return {
            x: point.x / 1280 * 300 + 250,
            y: point.y / 720 * 200 + 200
        }
    }

    function IpPosToCoord(point) {
        return {
            // x: point.x / 1280 * 300 + 250,
            // y: point.y / 720 * 200 + 200
            x: (point.x - 250) / 300 * 1280,
            y: (point.y - 200) / 200 * 720
        }
    }

    function drawAbs(dt) {
        ctx1.clearRect(0, 0, canvas1.width, canvas1.height);

        ctx1.rect(250, 200, 300, 200);
        ctx1.stroke();
        for (var sphAbs in spheroState.abs) {
            var sph = spheroState.abs[sphAbs];
            drawCircle(orthoToIpPos(sph), 5);
        }
        for (var sphAbs in spheroState.absIp) {
            var sph = spheroState.absIp[sphAbs];

            drawCircle(orthoToIpPos(sph), 2);
        }
        for (var i in corners) {
            var point = corners[i];

            drawCircle(coordToIpPos(point), 4, true);
        }
    }

    function drawRel(dt) {
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
        for (var name in spheroState.rel) {
            var sphdata = spheroState.rel[name];
            // console.log(sphdata);
            drawLine(ctx2,
                100,
                100,
                sphdata.x * 100 + 100, -sphdata.y * 100 + 100
            );

        }
        // for (var name in spheroState.drift) {
        //     var angle = spheroState.drift[name];

        //     drawLine(ctx2,
        //         100,
        //         100,
        //         Math.cos(angle) * 250 + 100,
        //         Math.sin(angle) * 250 + 100,
        //         3
        //     );
        // }
        for (var name in spheroState.angle) {
            var angle = spheroState.angle[name];

            drawLine(ctx2,
                100,
                100,
                Math.cos(-angle) * 250 + 100,
                Math.sin(-angle) * 250 + 100,
                2
            );
        }
    }

    function draw(dt) {
        drawAbs(dt);
        drawRel(dt);
        requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    function drawLine(ctx, x1, y1, x2, y2, thickness) {
        ctx.lineWidth = thickness || 1;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
    </script>
</body>

</html>
